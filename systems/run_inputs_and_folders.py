import os
import json
import argparse
import subprocess
from datetime import datetime
from argparse import Namespace
import os, sys
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
from systems import generate_inputs_and_folders as giaf 


def get_completed_files(log_path):
    """Return a set of basenames already recorded in the log file."""
    if not os.path.exists(log_path):
        open(log_path, "a").close()
        return set()
    with open(log_path, "r") as logf:
        return {line.strip().split(",")[1] for line in logf if line.strip()}


def log_completed_run(log_path, base_name):
    """Append a timestamped entry for a completed run."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open(log_path, "a") as logf:
        logf.write(f"{timestamp},{base_name}\n")


def main():
    parser = argparse.ArgumentParser(
        description="Run inputs generated by `generate_inputs_and_folders.py`"
    )

    parser.add_argument(
        "metadata_path",
        help="Path to metadata"
    )

    parser.add_argument(
        "-M", "--memory",
        default=45,
        required=False,
        help="Memory in GB for qmolpro job"
    )

    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print commands instead of executing them"
    )

    parser.add_argument("--qmolpro-path", default="~/q-scripts/qmolpro-generic")


    args = parser.parse_args()
    meta = giaf.read_metadata(args.metadata_path)

    # Prepare args for generate_file_paths
    args_dict = {
        "metadata_path": args.metadata_path,
        "dry_run": False,
        "output": None,
    }
    args_ns = Namespace(**args_dict)

    for file_path, folder_path, _, _ in giaf.generate_file_paths(args_ns, meta):
        log_path = os.path.join(folder_path, "runs.log")
        completed_files = get_completed_files(log_path)

        base_name = os.path.basename(file_path)
        if base_name in completed_files:
            print(f"‚úÖ Skipping already completed: {file_path}")
            continue

        cmd = f"{args.qmolpro_path} -M {args.memory} {base_name}"

        if args.dry_run:
            print(f"[DRY-RUN] Would run: {cmd} in {folder_path}")
            continue

        print(f"üöÄ Running: {cmd} in {folder_path}")
        try:
            subprocess.run(
                cmd,
                shell=True,
                check=True,
                cwd=folder_path,
                executable="/bin/bash"
            )
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Error running {cmd}: {e}")
            continue

        log_completed_run(log_path, base_name)
        print(f"üìù Logged run: {base_name}")


if __name__ == "__main__":
    main()

